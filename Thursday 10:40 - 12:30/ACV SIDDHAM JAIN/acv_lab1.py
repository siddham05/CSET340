# -*- coding: utf-8 -*-
"""ACV LAB1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14jQYjpJKeRI31soJd59-AK5MF1HicsEI
"""

import matplotlib.pyplot as plt
import numpy as np

def plot_same_plot(original, transformed, title, label1='Original', label2='Transformed', color1='blue', color2='green'):
    """Plot original and transformed objects on the same plot."""
    original = np.append(original, [original[0]], axis=0)
    transformed = np.append(transformed, [transformed[0]], axis=0)

    plt.figure(figsize=(8, 8))
    plt.plot(original[:, 0], original[:, 1], color=color1, label=label1, linestyle='dashed')
    plt.scatter(original[:, 0], original[:, 1], color=color1)

    plt.plot(transformed[:, 0], transformed[:, 1], color=color2, label=label2)
    plt.scatter(transformed[:, 0], transformed[:, 1], color=color2)

    plt.title(title)
    plt.grid(True)
    plt.gca().set_aspect('equal', adjustable='box')
    plt.legend()
    plt.show()

def translate(points, tx, ty):
    translation_matrix = np.array([[1, 0, tx], [0, 1, ty], [0, 0, 1]])
    return apply_transformation(points, translation_matrix)

def scale(points, sx, sy):
    scaling_matrix = np.array([[sx, 0, 0], [0, sy, 0], [0, 0, 1]])
    return apply_transformation(points, scaling_matrix)

def rotate(points, angle):
    rad = np.radians(angle)
    rotation_matrix = np.array([[np.cos(rad), -np.sin(rad), 0], [np.sin(rad), np.cos(rad), 0], [0, 0, 1]])
    return apply_transformation(points, rotation_matrix)

def reflect(points, axis='x'):
    if axis == 'x':
        reflection_matrix = np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]])
    elif axis == 'y':
        reflection_matrix = np.array([[-1, 0, 0], [0, 1, 0], [0, 0, 1]])
    else:
        reflection_matrix = np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]])
    return apply_transformation(points, reflection_matrix)

def shear(points, shx, shy):
    shear_matrix = np.array([[1, shx, 0], [shy, 1, 0], [0, 0, 1]])
    return apply_transformation(points, shear_matrix)

def apply_transformation(points, matrix):
    points_homogeneous = np.hstack((points, np.ones((points.shape[0], 1))))
    transformed_points = points_homogeneous @ matrix.T
    return transformed_points[:, :2]

#Triangle
points = np.array([[1, 1], [3, 1], [2, 3]])


translated_points = translate(points, 2, 1)
plot_same_plot(points, translated_points, "Translation (tx=2, ty=1)")


scaled_points = scale(points, 2, 2)
plot_same_plot(points, scaled_points, "Scaling (sx=2, sy=2)")

#Rotation
rotated_points = rotate(points, 45)
plot_same_plot(points, rotated_points, "Rotation (45 degrees)")

#Reflection
reflected_points = reflect(points, axis='y')
plot_same_plot(points, reflected_points, "Reflection (about y-axis)")

#Shearing
sheared_points = shear(points, 1, 0)
plot_same_plot(points, sheared_points, "Shearing (shx=1, shy=0)")

# omposite transformation: translation + rotation
composite_transformed = rotate(translate(points, 2, 1), 45)
plot_same_plot(points, composite_transformed, "Composite Transformation (Translate + Rotate)")

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

# Load the image
image = cv2.imread('example.jpg')

# Translation
def translate(image, tx, ty):
    height, width = image.shape[:2]
    translation_matrix = np.float32([[1, 0, tx], [0, 1, ty]])
    return cv2.warpAffine(image, translation_matrix, (width, height))

# Rotation
def rotate(image, angle):
    height, width = image.shape[:2]
    rotation_matrix = cv2.getRotationMatrix2D((width / 2, height / 2), angle, 1)
    return cv2.warpAffine(image, rotation_matrix, (width, height))

# Scaling
def scale(image, fx, fy):
    return cv2.resize(image, None, fx=fx, fy=fy, interpolation=cv2.INTER_LINEAR)

# Reflection
def reflect(image, axis):
    if axis == 'x':
        return cv2.flip(image, 0)
    elif axis == 'y':
        return cv2.flip(image, 1)
    elif axis == 'both':
        return cv2.flip(image, -1)

# Shearing (x-axis)
def shear(image, shear_factor):
    height, width = image.shape[:2]
    shear_matrix = np.float32([[1, shear_factor, 0], [0, 1, 0]])
    return cv2.warpAffine(image, shear_matrix, (int(width * (1 + shear_factor)), height))

# Shearing (y-axis)
def shear_y(image, shear_factor):
    height, width = image.shape[:2]
    shear_matrix = np.float32([[1, 0, 0], [shear_factor, 1, 0]])
    return cv2.warpAffine(image, shear_matrix, (width, int(height * (1 + shear_factor))))

# Example usage:
translated_image = translate(image, 50, 30)
rotated_image = rotate(image, 45)
scaled_image = scale(image, 0.5, 0.5)
reflected_image = reflect(image, 'y')
sheared_image = shear(image, 0.5)
sheared_image_y = shear_y(image, 0.5)

# Display the images using cv2_imshow
cv2_imshow(translated_image)
cv2_imshow(rotated_image)
cv2_imshow(scaled_image)
cv2_imshow(reflected_image)
cv2_imshow(sheared_image)
cv2_imshow(sheared_image_y)

